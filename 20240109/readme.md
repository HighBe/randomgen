## 在内联汇编中加入了mstore mload 等
## 生成keccak256语句的函数加入，之后需要将生成的语句融入到内联汇编中
## 生成数组 加入push相关内容
## solidity 数组
- solidity数组分为storage和memory两种
- 只有动态storage类型的数组才能使用push和pop方法
- 尽量将所有的数组都定义为状态变量
- 删除元素的两种方法：
  + `delete`: `delete a[2]`删除指定位置的元素，但是实际上只是将该位置的元素置为零
  + `pop`:`a.pop()`只能删除末尾的元素

### 动态数组
- 定义动态数组
  ```
  //实例化一个初始长度为3的值为0的动态数组
  uint[] a;
  a = new uint[](3);
  ```
- 如果动态数组是状态变量，并且没有在函数中有 aa = new uint[](3)这种语句，那么只能使用push会将数据从起始位置放入
- 如果有aa = new uint[](3)这种语句，则使用push是在数组的末尾aa[3]开始增加内容，前面的3个为默认值0.
### 二维数组
- 二维数组，solidity中的二维数组定义方式与一般的语言不同，uint[2][3] a,是定义了一个三行二列的数组，但是在读取的时候，顺序是与一般的语言相同，比如a[2][1]是一个数组的第3行第2列.
- uint[2][] aa;如果没有 aa = new uint[2][](10)，那么只能使用aa.push([1,2])或aa.push(aaa) 其中aaa是一个uint[2]的数组。只有放入过值的位置才能再使用aa[2][2] = 4这种赋值语句赋值。
- 如果有aa = new uint[2][](10)，对于直接申请的部分可以直接使用赋值语句赋值。
#### 动态二维数组
```
uint[2][] a;
a.push([1,2]);   // a[0][0] = 1 a[0][1] = 2

uint[][2] aa;
aa[0].push(1);  // aa[0][0] = 1
aa[1].push(2);  // aa[0][1] = 2

uint[][] aaa;
aaa.push([1]);  // aaa[0][0] = 1一开始如果不是push一个数组而是push一个数的话，编译能通过但是运行会报错。
aaa[0].push(2); // aaa[0][1] = 2
```
如果有加入实例化
```
uint[2][] a;
a = new uint[2][](3);
```
**没要找到其他两种动态二维数组的实例化方法**
- 初始化的时候不允许一维数组长度不同，如`uint[][] a= [[1,2,3,],[5,6],[7,8,9]]`是不允许的。
## 加入一定的常量




